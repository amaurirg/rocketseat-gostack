- Criar o app:
    create-react-app gobarber-web --template=typescript

- Copiar as devDependencies para package.json:
    "devDependencies": {
        "@testing-library/jest-dom": "^4.2.4",
        "@testing-library/react": "^9.3.2",
        "@testing-library/user-event": "^7.1.2",
        "@types/axios": "^0.14.0",
        "@types/jest": "^24.0.0",
        "@types/node": "^12.0.0",
        "@types/react": "^16.9.0",
        "@types/react-dom": "^16.9.0",
        "@types/react-router-dom": "^5.1.4",
        "@types/styled-components": "^5.1.0",
        "@typescript-eslint/eslint-plugin": "^2.28.0",
        "@typescript-eslint/parser": "^2.28.0",
        "axios-mock-adapter": "^1.18.1",
        "eslint": "^6.8.0",
        "eslint-config-airbnb": "^18.1.0",
        "eslint-config-prettier": "^6.10.1",
        "eslint-import-resolver-typescript": "^2.0.0",
        "eslint-plugin-import": "^2.20.1",
        "eslint-plugin-jsx-a11y": "^6.2.3",
        "eslint-plugin-prettier": "^3.1.3",
        "eslint-plugin-react": "^7.19.0",
        "eslint-plugin-react-hooks": "^2.5.0",
        "prettier": "^2.0.4",
        "react-app-rewired": "^2.1.5",
        "ts-jest": "^25.4.0"
      }

- Instalar as dependências:
    yarn

- Instalar outras dependências:
    yarn add styled-components
    yarn add @types/styled-components -D

- Criar arquivo src/styles/global.ts:
    import { createGlobalStyle } from 'styled-components';

    export default createGlobalStyle`
      * {
        margin: 0;
        padding: 0;
        outline: 0;
        box-sizing: border-box;
      }

      body {
        background: #312E38;
        color: #FFF;
        -webkit-font-smoothing: antialiased;
      }

      body, input, button {
        font-font-family: 'Roboto Slab', serif;
        font-size: 16px;
      }
      
      h1, h2, h3, h4, h5, h6, strong {
        font-weight: 500;
      }

      button {
        cursor: pointer;
      }
    `;

- Em src/App.tsx:
    import React from 'react';
    import GlobalStyle from './styles/global';

    const App: React.FC = () => (
      <>
      <h1>Hello World</h1>
      <GlobalStyle />
      </>
    );

    export default App;

- Instalar os ícones e polished para cores:
    yarn add react-icons 
    yarn add polished
- Execute o projeto:
    yarn start

- Vamos criar 2 componentes para a tela de login dividindo o form da imagem:
  - Vamos deixar criado os estilos em src/pages/SignIn/styles.tsx:
      import styled from 'styled-components';

      export const Container = styled.div``;
      export const Content = styled.div``;
      export const Background = styled.div``;

  - Em src/pages/SignIn/index.tsx:
      import React from 'react';
      import { Container, Content, Background } from './styles';
      import { FiLogIn } from 'react-icons/fi';
      import logoImg from '../../assets/logo.svg';

      const SignIn: React.FC = () => (
        <Container>
          <Content>
            <img src={logoImg} alt="GoBarber" />
            <form>
              <h1>Faça seu login</h1>
              <input placeholder="E-mail" />
              <input type="password" placeholder="Senha" />
              <button type="submit">Entrar</button>
              <a href="forgot">Esqueci minha senha</a>
            </form>
            <a href="login">
              <FiLogIn />
              Criar conta
              </a>
          </Content>
          <Background />
        </Container>
      );

      export default SignIn;

EXPLICANDO CSS
==============
- Em src/pages/SignIn/styles.tsx:
    import styled from 'styled-components';
    import { shade } from 'polished';
    import signInBackgroundImg from '../../assets/sign-in-background.png';

    styled-components: para usar os estilos como componentes
    shade: facilita trabalhar com cores, exemplo para o botão ficar mais escuro
    signInBackgroundImg: imagem salva na pasta assets

    export const Container = styled.div`
      height: 100vh;  ocupa toda a altura da área visualizada
      display: flex;  um componente ao lado do outro
      align-items: stretch; para todos os componentes terem height: 100vh
    `;

    export const Content = styled.div`
      display: flex;  um componente ao lado do outro
      flex-direction: column; para os componentes ficarem abaixo um do outro
      align-items: center; alinhar os itens ao centro
      place-content: center;  todo o conteúdo dos eixos "x" e "y" ficará ao centro
                              o mesmo que justify-content: center e align-items: center
      width: 100%;  ocupará o máximo da tela exceto a imagem Background ao lado
      max-width: 700px; ocupará no máximo 700px
      Isso quer dizer que a imagem Background completará o restante da tela com flex: 1 para isso. Nunca reduzirá o tamanho do conteúdo e nunca ultrapassará 700px.

      form {
        margin: 80px 0; distanciar em cima e abaixo do restante
        width: 340px; para ficar um pouco menor
        text-align: center; alinhar os itens ao centro
        
        h1 {
          margin-bottom: 24px;  distanciar abaixo
        }

        input {
          background: #232129;  cor de fundo
          border-radius: 10px;  borda arredondada
          border: 2px solid #232129;  borda que será enfatizada
          padding: 16px;  distanciar internamente
          width: 100%;  ocupar o máximo que puder
          color:#f4ede8;  cor do texto a ser digitado do input

          &::placeholder {
            color: #666360; cor do placeholder
          }

          & + input { todo input precedido por outro, ou seja, menos o primeiro
            margin-top: 8px;  margem para distanciar do outro input acima
          }
        }

        button {
          background: #FF9000;  cor de fundo
          height: 56px; tamanho fixo
          border-radius: 10px; borda arredondada
          border: 0; sem borda
          padding: 0 16px; distanciar internamente
          color: #312e38; cor do texto do botão
          width: 100%;  ocupar o máximo que puder
          font-weight: 500; "meio negrito"
          margin-top: 16px; distanciar acima
          transition: background-color 0.2s;  mudar gradualmente a cor
          
          &:hover {
            background: ${shade(0.2, '#FF9000')}; shade para botão ficar 0.2 (20%) mais escuro 
          }
        }

        a {
          color: #f4ede8;
          display: block; ocupa toda a linha
          margin-top: 24px;
          text-decoration: none;  sem sublinhado
          transition: color 0.2s; mudar gradualmente a cor

          &:hover {
            color: ${shade(0.2, '#f4ede8')}; shade para link ficar 0.2 (20%) mais escuro 
          }
        }
      }

      > a {   somente a que estiverem diretamente no form e não dentro de outro componente
        color: #FF9000;
        margin-top: 24px;
        text-decoration: none;  sem sublinhado
        transition: color 0.2s; mudar gradualmente a cor
        display: flex;  um componente ao lado do outro
        align-items: center;

        svg {   estilo do ícone
          margin-right: 16px;
        }

        &:hover {
          color: ${shade(0.2, '#FF9000')};
        }
      }
    `;

    export const Background = styled.div`
      flex: 1;  ocupará todo o espaço menos os 700px do Content
      background: url(${signInBackgroundImg}) no-repeat center; a imagem de fundo importada
      background-size: cover; para não ficar com espaços em volta, ocupando todo o espaço que sobrou
    `;


ISOLANDO COMPONENTES
====================
Como usaremos input e button em vários locais, a melhor forma de reaproveitarmos é separando esses componentes, transformando-os em globais.

Criaremos uma pasta components e dentro cada componente terá dois arquivos: um index e um style.
- Em src/components temos:
    Input
      index.tsx
      styles.css
    Button
      index.tsx
      styles.css

- Em src/components/Input/index.tsx:
    import React, { InputHTMLAttributes } from 'react';
    import { Container } from './styles';

    interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
      name: string;
    }

    const Input: React.FC<InputProps> = () => (
      <Container>
        <input type="text" />
      </Container>
    );

    export default Input;

  Importamos InputHTMLAttributes que contém os atributos do <input> do HTML.
  Importamos Container para o estilo.
  Criamos uma interface para utilizarmos esses atributos e incluir o name como obrigatório, pode ver que não tem interrogação (name?: string). Extendemos de InputHTMLAttributes que tem como parâmetro HTMLInputElement.
  Passamos a interface como parâmetro ao componente para que o mesmo tenha todos os atributos que o <input> do HTML tem.


- Em src/components/Input/styles.ts:
    import styled from 'styled-components';

    export const Container = styled.div``;


- Em src/components/Button/index.tsx:
    import React, { ButtonHTMLAttributes } from 'react';

    type ButtonProps = ButtonHTMLAttributes<HTMLButtonElement>;

    const button: React.FC<ButtonProps> = () => <button type="button">teste</button>;

    export default button;

  Importamos ButtonHTMLAttributes que contém os atributos do <input> do HTML.
  Não precisamos criar interface no caso do button porque nosso componente não terá novas propriedades e não vamos sobrescrever nenhum atributo já existente desse elemento HTML, ou seja, será uma interface vazia. Para isso faremos uma forma simplificada com type que é uma forma de criarmos tipagem de objetos que são compostas de outra tipagem.
  Passamos a interface como parâmetro ao componente para que o mesmo tenha todos os atributos que o <button> do HTML tem. Poderíamos passar diretamente ButtonHTMLAttributes<HTMLButtonElement> mas ficaria muito grande e por isso uma boa prática é criar um type e passá-lo como parâmetro.


- Em src/components/Button/styles.ts:
    import styled from 'styled-components';

    export const Container = styled.button``;
  
  Aqui não é <div> e sim <button>

Passamos as props dos nossos componentes:
  - Em src/components/Input/index.tsx:
      const Input: React.FC<InputProps> = (props) => (
        <Container>
          <input {...props} />
        </Container>
      );
  
  - Em src/components/Button/index.tsx:
      const button: React.FC<ButtonProps> = (props) => <button type="button" {...props}>teste</button>;
    
    Agora precisamos pegar o texto "Entrar" do button. Vamos alterar a linha acima:
      const button: React.FC<ButtonProps> = ({ children, ...rest }) => (
        <button type="button" {...rest}>
          {children}
        </button>);

    Pegamos o texto do button utilizando desestruturação com children e todas as outras propriedades que vierem ficarão em ...rest e passamos o nome do button com children.

    OBS: Em projetos que não estejam utilizando Typescript, o eslint dará um erro informando que o eslint vem junto com a necessidade de adicionar tipagem estática com a bilioteca react/prop-types mas isso só faz sentido se não estiver usando Typescript porque o mesmo já faz isso.

    - Importamos o Container e substituímos <button> por <Container>:
        import React, { ButtonHTMLAttributes } from 'react';
        import { Container } from './styles';

        type ButtonProps = ButtonHTMLAttributes<HTMLButtonElement>;

        const button: React.FC<ButtonProps> = ({ children, ...rest }) => (
          <Container type="button" {...rest}>
            {children}
          </Container>);

        export default button;

Agora nos campos de input deveremos inserir os ícones e ajustar a margem:
- Em src/pages/SignIn/index.tsx:
    import { FiLogIn, FiMail, FiLock } from 'react-icons/fi';

    <Input name="email" icon={FiMail} placeholder="E-mail" />
    <Input name="password" icon={FiLock} type="password" placeholder="Senha" />

  Isso gerará um erro porque precisamos informar na interface a tipagem dos icons:
  - Em src/components/Input/index.tsx:
      icons: React.ComponentType;

    O tipo de icon é um componente (FiMail e FiLock) e o React tem uma propriedade chamada ComponentType para receber esse componente como propriedade.

    Precisamos receber as propriedades, inclusive os ícones. Precisamos informar ao React um outro nome porque ele não reconhece <icon> como componente. Então passamos icon: Icon:
      const Input: React.FC<InputProps> = ({icon: Icon, ...rest}) => (
        <Container>
          <input {...rest} />
        </Container>
      );

    Agora como fazer para que o React saiba as propriedades que Icon Tem quando fizermos <Icon /> ?
      Por exemplo, se passarmos:
        icons: React.ComponentType<{ size: string; }>;
      Conseguimos acessar size em <Icon size={12} />
      Sendo assim, importaremos as propriedades que um ícone pode ter:
        import { IconBaseProps } from 'react-icons';
      
      Passamos como parâmetro para icons: React.ComponentType; e assim teremos acesso às propriedades de Icon e deixamos icon como opcional (?):
        icon?: React.ComponentType<IconBaseProps>;

      Fazemos uma verificação se existe o ícone para poder mostrá-lo:
        {Icon && <Icon size={20} />}

      Agora o ícone aparece, porém fora do input. Vamos colocá-lo dentro:
        - Vamos mover o input de src/pages/SignIn/styles.ts para src/pages/SignIn/styles.ts:
          import styled from 'styled-components';

          export const Container = styled.div`

            input {
              background: #232129;
              border-radius: 10px;
              border: 2px solid #232129;
              padding: 12px;
              width: 100%;
              color:#f4ede8;

              &::placeholder {
                color: #666360;
              }

              & + input {
                margin-top: 8px;
              }
            }
          `;

        - Movemos as propriedades do input para o Container:
            import styled from 'styled-components';

            export const Container = styled.div`
                background: #232129;
                border-radius: 10px;
                border: 2px solid #232129;
                padding: 12px;
                width: 100%;
                color:#f4ede8;

              input {

                &::placeholder {
                  color: #666360;
                }

                & + input {
                  margin-top: 8px;
                }
              }
            `;

        - Alinhamos os icons e os inputs:
            display: flex;
            align-items: center;

        - No input adicionamos:
            flex: 1;
            background: transparent;
            border: 0;

        - Como o ícone é opcional, colocaremos a margem nele para distanciar do input:
            svg {
              margin-right: 16px;
            }
        
        - Alteramos a cor do Container e do input para ficarem iguais:
          No Container:
            color: #666360;
          No input:
            color:#f4ede8;

      Ajustaremos as margens dos inputs movendo-a para o Container e o nome para div:
        & + div {
          margin-top: 8px;
        }

Passaremos o estilo do button para seu componente:
  - Movemos de src/pages/SignIn/styles.ts para src/components/Button/styles.ts:
      background: #FF9000;
      height: 46px;
      border-radius: 10px;
      border: 0;
      padding: 0 16px;
      color: #312e38;
      width: 100%;
      font-weight: 500;
      margin-top: 16px;
      transition: background-color 0.2s;
      
      &:hover {
        background: ${shade(0.2, '#FF9000')};
      }
  
  - Importamos shade:
      import { shade } from 'polished';



*****************************
* OS ARQUIVOS FICARAM ASSIM *
*****************************

- Em src/pages/SignIn/index.tsx:
    import React from 'react';
    import { Container, Content, Background } from './styles';
    import { FiLogIn, FiMail, FiLock } from 'react-icons/fi';
    import logoImg from '../../assets/logo.svg';
    import Input from '../../components/Input';
    import Button from '../../components/Button';

    const SignIn: React.FC = () => (
      <Container>
        <Content>
          <img src={logoImg} alt="GoBarber" />
          <form>
            <h2>Faça seu login</h2>
            <Input name="email" icon={FiMail} placeholder="E-mail" />
            <Input name="password" icon={FiLock} type="password" placeholder="Senha" />
            <Button type="submit">Entrar</Button>
            <a href="forgot">Esqueci minha senha</a>
          </form>
          <a href="login">
            <FiLogIn />
            Criar conta
          </a>
        </Content>
        <Background />
      </Container>
    );

    export default SignIn;

- Em src/pages/SignIn/styles.ts:
    import styled from 'styled-components';
    import { shade } from 'polished';
    import signInBackgroundImg from '../../assets/sign-in-background.png';

    export const Container = styled.div`
      height: 100vh;
      display: flex;
      align-items: stretch;
    `;

    export const Content = styled.div`
      display: flex;
      flex-direction: column;
      align-items: center;
      place-content: center;
      width: 100%;
      max-width: 700px;

      form {
        margin: 40px 0;
        width: 340px;
        text-align: center;
        
        h2 {
          margin-bottom: 16px;
        }

        a {
          color: #f4ede8;
          display: block;
          margin-top: 24px;
          text-decoration: none;
          transition: color 0.2s;

          &:hover {
            color: ${shade(0.2, '#f4ede8')};
          }
        }
      }

      > a {
        color: #FF9000;
        margin-top: 24px;
        text-decoration: none;
        transition: color 0.2s;
        display: flex;
        align-items: center;

        svg {
          margin-right: 16px;
        }

        &:hover {
          color: ${shade(0.2, '#FF9000')};
        }
      }
    `;

    export const Background = styled.div`
      flex: 1;
      background: url(${signInBackgroundImg}) no-repeat center;
      background-size: cover;
    `;

- Em src/components/Button/index.tsx:
    import React, { ButtonHTMLAttributes } from 'react';
    import { Container } from './styles';

    type ButtonProps = ButtonHTMLAttributes<HTMLButtonElement>;

    const button: React.FC<ButtonProps> = ({ children, ...rest }) => (
      <Container type="button" {...rest}>
        {children}
      </Container>);

    export default button;

- Em src/components/Button/styles.ts:
    import styled from 'styled-components';
    import { shade } from 'polished';

    export const Container = styled.button`
      background: #FF9000;
      height: 46px;
      border-radius: 10px;
      border: 0;
      padding: 0 16px;
      color: #312e38;
      width: 100%;
      font-weight: 500;
      margin-top: 16px;
      transition: background-color 0.2s;
      
      &:hover {
        background: ${shade(0.2, '#FF9000')};
      }
    `;

- Em src/components/Input/index.tsx:
    import React, { InputHTMLAttributes } from 'react';
    import { IconBaseProps } from 'react-icons';
    import { Container } from './styles';

    interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
      name: string;
      icon?: React.ComponentType<IconBaseProps>;
    }

    const Input: React.FC<InputProps> = ({ icon: Icon, ...rest }) => (
      <Container>
        {Icon && <Icon size={20} />}
        <input {...rest} />
      </Container>
    );

    export default Input;

- Em src/components/Input/styles.ts:
    import styled from 'styled-components';

    export const Container = styled.div`
        background: #232129;
        border-radius: 10px;
        border: 2px solid #232129;
        padding: 12px;
        width: 100%;
        color: #666360;

        display: flex;
        align-items: center;

        & + div {
          margin-top: 8px;
        }

      input {
        flex: 1;
        background: transparent;
        border: 0;
        color:#f4ede8;

        &::placeholder {
          color: #666360;
        }

      }
      svg {
        margin-right: 16px;
      }
    `;

********************
* FIM DOS ARQUIVOS *
********************


UTLIZANDO UNFORM
================

Quando utilizamos estados, toda vez que um componente sofre alteração, o componente é renderizado e mostrado novamente. No caso do <input> temos 3 e cada letra digitada conta como uma alteração, comprometendo a performance. Então utilizaremos o UnForm que é uma biblioteca feita pela Rocketseat.

- Instalar as bibliotecas:
    yarn add @unform/core @unform/web
    @unform/core: para web e mobile
    @unform/web: integração do UnForm para ReactJS pode ser trocado para mobile no React Native

- Em src/pages/SignUp/index.tsx:
    import { Form } from '@unform/web';

  - Trocamos <form> por <Form>

  - No componente SignUp vamos alterar para colocar o código dentro do return e criar uma função que será executada a partir do <Form>:

      import React from 'react';
      import { Form } from '@unform/web';
      import { FiMail, FiLock, FiUser, FiArrowLeft } from 'react-icons/fi';
      import { Container, Content, Background } from './styles';
      import logoImg from '../../assets/logo.svg';
      import Input from '../../components/Input';
      import Button from '../../components/Button';

      const SignUp: React.FC = () => {
        function handleSubmit(data: object): void {
          console.log(data);
        }

        return (
          <Container>
            <Background />
            <Content>
              <img src={logoImg} alt="GoBarber" />
              <Form onSubmit={handleSubmit}>
                <h2>Faça seu cadastro</h2>
                <Input name="name" icon={FiUser} placeholder="Nome" />
                <Input name="email" icon={FiMail} placeholder="E-mail" />
                <Input name="password" icon={FiLock} type="password" placeholder="Senha" />
                <Button type="submit">Cadastrar</Button>
              </Form>
              <a href="login">
                <FiArrowLeft />
              Voltar para login
            </a>
            </Content>
          </Container>
        );
      };

      export default SignUp;

    export default SignUp;

Agora precisamos informar quais campos serão monitorados pelo UnForm no submit. Vamos utilizar nosso Input pra fazer a lógica de registro pois ele será utilizado em muitos locais:
- Em src/components/Input/index.tsx:
  - Importamos um hook que recebe como parâmetro o nome do campo que retorna várias propriedades:
    import {useField} from '@unform/core';
  - Vamos colocar um corpo e colocar o código dentro de um return:
      import React, { InputHTMLAttributes } from 'react';
      import {useField} from '@unform/core';
      import { IconBaseProps } from 'react-icons';
      import { Container } from './styles';

      interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
        name: string;
        icon?: React.ComponentType<IconBaseProps>;
      }

      const Input: React.FC<InputProps> = ({ icon: Icon, ...rest }) => {

        return (
          <Container>
            {Icon && <Icon size={20} />}
            <input {...rest} />
          </Container>
        );
      };

      export default Input;

  - Pegamos esses dados do campo:
      const { fieldName, defaultValue, error, registerField } = useField(name);

      registerField: é o registro que precisamos fazer assim que o input for exibido em tela com useEffect.
  
  - Vamos importar useEffect e utilizá-la. Deixaremos o arquivo assim por enquanto:
      import React, { InputHTMLAttributes, useEffect, useRef } from 'react';
      import { useField } from '@unform/core';
      import { IconBaseProps } from 'react-icons';
      import { Container } from './styles';

      interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
        name: string;
        icon?: React.ComponentType<IconBaseProps>;
      }

      const Input: React.FC<InputProps> = ({ name, icon: Icon, ...rest }) => {
        const inputRef = useRef(null);
        const { fieldName, defaultValue, error, registerField } = useField(name);

        useEffect(() => {
          registerField({
            name: fieldName,
            ref: inputRef.current,
            path: 'value',
          });
        }, [fieldName, registerField]);

        return (
          <Container>
            {Icon && <Icon size={20} />}
            <input ref={inputRef} {...rest} />
          </Container>
        );
      };

      export default Input;

    Explicando:

          

      Assim que o componente for exibido em tela chamamos registerField que recebe algumas propriedades.
        name: nome do campo (fieldName)
        ref:  no React são formas de acessar o elemento de uma forma direta sem precisar armazenar 
              em um estado por exemplo. Seria como document.querySelector('input')
              Para isso importamos useRef e criamos a referência com valor inicial nulo:
                const inputRef = useRef(null);
              - Passamos a referência no input:
                <input ref={inputRef} {...rest} />
              Isso associa o input com useRef, ou seja, se acessarmos inputRef teremos acesso ao elemento na DOM como se estivesse usando um JS normal.
              inputRef tem a propriedade current onde fica o input.
        path: de onde o UnForm vai buscar, dentro de ref, o valor do input. Seria como:
              document.querySelector('input').value
        [fieldName, registerField]: informamos que estamos utilizando as variáveis

        No momento que demos o submit, o unForm foi em cada um dos inputs que foram registrados, acessou o elemento e pegou os valores(value) e retornou um campo com o nome exatamente como foi passado no fieldName:
          {name: "AMAURI ROSSETTI GIOVANI", email: "amauri.giovani@gmail.com", password: "123"}
          name: é o que está em fieldName
          ref: é o que dá acesso ao input no HTML
          path: é onde ele vai buscar esse valor

  Se preenchermos o form de cadastro podemos ver no console.log os dados preenchidos.

  Se quisermos setar um valor defaul para o input, usamos o defaultValue:
    <input defaultValue={defaultValue} ref={inputRef} {...rest} />

    Agora se quiséssemos preencher o defaultValue colocaríamos em src/pages/SignUp/index.tsx:
      - Na tag <Form> colocamos:
        <Form initialData={{ name: 'Amauri' }} onSubmit={handleSubmit}>
      Colocamos duas chaves porque a primeira indica que estamos passando um código JS dentro do código HTML e a segunda indica que estamos passando um objeto do JS mesmo {name: 'Amauri'} onde name é o mesmo name do input. Agora quando o input for mostrado em tela virá preenchido com 'Amauri'.

Vamos colocar uma borda no input e no ícone mas não podemos utilizar o focus tradicional no css do input:
    &:focus {
      background: #fff;
    }
Precisaremos colocar para o container, então mexeremos no src/components/Input/index.tsx:
  onFocus={} => para saber quando o input recebeu foco, ou seja clicado
  onBlur={} => para saber quando o input perdeu foco, ou seja o usuário saiu do input

- Vamos utilizar o useState para armazenar os estados do input:
    import React, { InputHTMLAttributes, useEffect, useRef, useState } from 'react';

- Inicializamos o valor do focus como false:
    const [isFocused, setIsFocused] = useState(false);

- Vamos receber o estado do focus, lembrando que temos que criar um função (arrow function) para não executar assim que o input for mostrado em tela:
  onFocus={() => setIsFocused(true)}
  onBlur={() => setIsFocused(false)}

- Passaremos para o <Container> porque ele que conseguirá estilizar lá dentro:
    <Container isFocused={isFocused}>
  
  Porém <Container> não tem a propriedade isFocused, então criaremos uma interface em src/components/Input/styles.ts:
  interface ContainerProps {
    isFocused: boolean;
  }

E passamos como parâmetro:
  export const Container = styled.div<ContainerProps>`

Agora importamos css, pegamos as props e quando isFocused for true, substituiremos as cores da borda e do ícone:
  import styled, { css } from 'styled-components';

  ${(props) =>
    props.isFocused && css`
      color: #ff9000;
      border-color: #ff9000;
  `}

Agora vamos mexer no onBlur para quando perder o foco. Criaremos uma nova função dentro da função existente const Input: React.FC<InputProps> ... :
  function handleInputBlur() {
    setIsFocused(false)
  }
  
  Substituiremos:
    onBlur={() => setIsFocused(false)}
  Por:
    onBlur={handleInputBlur}

IMPORTANTE!!!
=============
No JS, quando criamos uma função dentro de outra, toda vez que a função Input for chamada ela irá recriar a função handleInputBlur na memória. Não tem muito problema na questão visual porém no React sempre que alteramos um estado, propriedade ou um componente pai ele é renderizado novamente.
A melhor forma de fazermos é:
  "SEMPRE QUE UMA FUNÇÃO FOR CRIADA DENTRO DE UM COMPONENTE, NÓS NÃO VAMOS CRIAR ELA COMO UMA FUNCTION, UTILIZAREMOS UM HOOK DO REACT CHAMADO useCallback".
Esse useCallback é uma forma de criarmos funções dentro do nosso componente que não são recriadas na memória toda vez que o componente atualiza. Elas são memorizadas, ficam salvas na memória e se precisarem alterar conseguimos dizer pra elas "agora que você recarregue". Entenderemos no decorrer do curso.

- Vamos alterar a function:
    function handleInputBlur() {
      setIsFocused(false)
    }

  Por:
    const handleInputBlur = useCallback(() => {
      setIsFocused(false)
    }, []);

  O useCallback recebe dois parâmetros, assim como useEffect. No segundo não passaremos nada, deixando o array vazio.
  Então ele criará uma função e ele só vai recriá-la se as variáveis desse array forem alteradas. Como o array estará vazio, ele nunca irá recriá-la.

- Faremos para onFocus também:
    const handleInputFocus = useCallback(() => {
      setIsFocused(true);
    }, []);

    onFocus={handleInputFocus}

    Assim garantimos que essa função será criada uma única vez independente de quantas vezes o componente for atualizado ou renderizado.

Agora vamos deixar somente o ícone, sem a borda, com a nova cor sempre que o input perder o foco e estiver preenchido.
- Criamos um novo estado para armazenar quando o input estiver preenchido:
    const [isFilled, setIsFilled] = useState(false);

- Faremos uma verificação para saber se o input está preenchido. Utilizaremos inputRef.current porém o React não sabe o que é isso. Precisamos informar que essa referência (inputRef) está armazenando o valor de um input. Como fazemos isso? Passamos um parâmetro (<HTMLInputElement>) para dizer à nossa referência que ela está armazenando a referência de um input dentro do HTML. Agora temos acesso ao input, bem como ao seu value (inputRef.current.value):
  if(inputRef.current?.value) {
    setIsFilled(true);
  } else {
    setIsFilled(false);
  }

  Utilizamos a interrogação em inputRef.current?.value porque seu valor inicial é nulo, então se ele tiver um valor aí sim faremos a verificação do value dele.
  Se conter um valor seta o valor para true e caso contrário seta para false.

Conseguimos reduzir esse código utilizando transformando-o em booleano:
  setIsFilled(!!inputRef.current?.value);

  Se o inputRef tiver algum valor ele retorna true e caso contrário retorna false.

- Em src/components/Input/index.tsx precisamos passar o isFilled para o Container:
    <Container isFilled={isFilled} isFocused={isFocused}>

- Em src/components/Input/styles.ts
  - Informamos isFilled na interface:
      interface ContainerProps {
        isFocused: boolean;
        isFilled: boolean;
      }

  - Dentro do estilo do Container deixamos somente o ícone com a cor laranja:
    ${(props) =>
      props.isFilled && css`
        color: #ff9000;
    `}

Agora, quando preenchermos o input e sairmos dele o ícone ficará laranja e se não preenchermos e sairmos ele volta a cor normal.


*****************************
* OS ARQUIVOS FICARAM ASSIM *
*****************************

- Em src/components/Input/index.tsx:
    import React, { InputHTMLAttributes, useEffect, useRef, useState, useCallback } from 'react';
    import { useField } from '@unform/core';
    import { IconBaseProps } from 'react-icons';
    import { Container } from './styles';

    interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
      name: string;
      icon?: React.ComponentType<IconBaseProps>;
    }

    const Input: React.FC<InputProps> = ({ name, icon: Icon, ...rest }) => {
      const inputRef = useRef<HTMLInputElement>(null);
      const [isFocused, setIsFocused] = useState(false);
      const [isFilled, setIsFilled] = useState(false);
      const { fieldName, defaultValue, error, registerField } = useField(name);

      const handleInputFocus = useCallback(() => {
        setIsFocused(true);
      }, []);

      const handleInputBlur = useCallback(() => {
        setIsFocused(false)

        setIsFilled(!!inputRef.current?.value);
      }, []);

      useEffect(() => {
        registerField({
          name: fieldName,
          ref: inputRef.current,
          path: 'value',
        });
      }, [fieldName, registerField]);

      return (
        <Container isFilled={isFilled} isFocused={isFocused}>
          {Icon && <Icon size={20} />}
          <input
            onFocus={handleInputFocus}
            onBlur={handleInputBlur}
            defaultValue={defaultValue}
            ref={inputRef}
            {...rest} />
        </Container>
      );
    };

    export default Input;

-Em src/components/Input/styles.ts:
  import styled, { css } from 'styled-components';

  interface ContainerProps {
    isFocused: boolean;
    isFilled: boolean;
  }

  export const Container = styled.div<ContainerProps>`
      background: #232129;
      border-radius: 10px;
      border: 2px solid #232129;
      padding: 12px;
      width: 100%;
      color: #666360;

      display: flex;
      align-items: center;

      & + div {
        margin-top: 8px;
      }

      ${(props) =>
        props.isFocused && css`
          color: #ff9000;
          border-color: #ff9000;
      `}

      ${(props) =>
        props.isFilled && css`
          color: #ff9000;
      `}

    input {
      flex: 1;
      background: transparent;
      border: 0;
      color:#f4ede8;

      &::placeholder {
        color: #666360;
      }

    }
    svg {
      margin-right: 16px;
    }
  `;

********************
* FIM DOS ARQUIVOS *
********************



VALIDAÇÃO DO FORMULÁRIO DE CADASTRO
===================================

- Instalar a biblioteca para validação de formulários:
    yarn add yup
    yarn add @types/yup -D

Podemos importar yup de duas formas: por validação de cada item como validação de e-mail, validação de mínimo de tamanho, etc ou tudo. Importaremos tudo que tem dentro de yup como uma variável chamada Yup:
  import * as Yup from 'yup';

- Em src/pages/SignUp/index.tsx:
    Substituiremos:
      const SignUp: React.FC = () => {
        function handleSubmit(data: object): void {
          console.log(data);
        }

    Por:
      const SignUp: React.FC = () => {
        const handleSubmit = useCallback(async (data: object) => {
          try {
            const schema = Yup.object().shape({
              name: Yup.string().required('Nome obrigatório'),
              email: Yup.string().required('E-mail obrigatório').email('Digite um e-mail válido'),
              password: Yup.string().min(6, 'No mínimo 6 dígitos'),
            });

            await schema.validate(data, {
              abortEarly: false,
            });
          } catch (err) {
            console.log(err);
          }
        }, []);

    schema: quando queremos validar um objeto inteiro
    Yup.object: os dados que estamos recebendo para validar estarão no formato de objeto
    shape: a forma como serão os dados
      name: Yup.string().required() => tipo string e obrigatório
        Se colocarmos o ponto no required veremos os tipos de validação que podemos fazer
      email: ... .email() => garante que terá @, domínio e TLD’s (categorias dos sites)
      password: Yup.string().min(6) => obrigatório no mínimo 6 dígitos
    
    await schema.validate(data, {
      abortEarly: false,
    });

    validate: valida os dados
    data: os dados vindos do input (nome, email e senha)
    abortEarly: false => como yup retorna por padrão apenas o primeiro erro na validação, colocamos isso para que ele mostre todos os campos com erro.

    Transformamos a função para arrow function, usamos o useCallback, async/await e tiramos o void.



PASSANDO OS ERROS PARA DENTRO DO INPUT
======================================

Conseguimos chamar algumas funções do formulário para setar ou buscar um valor ou erro de forma dinâmica. Para isso usaremos o conceito de ref do React para termos acesso direto ao formulário.
- Importamos useRef do React:
    import React, { useCallback, useRef } from 'react';

- Criamos uma variável para usar o useRef e imprimir no console para ver o retorno:
    const formRef = useRef(null);
    console.log(formRef);

    Resposta:

      current:
        clearField: ƒ (r)         => limpar um campo
        getData: ƒ ()             => pegar todos os dados do formulário
        getErrors: ƒ ()           => pegar todos os erros do formulário
        getFieldError: ƒ (r)      => pegar o erro de um input específico
        getFieldRef: ƒ (r)        => pegar a referência de um campo específico
        getFieldValue: ƒ (r)      => pegar o valor de um input específico
        reset: ƒ (r)              => resetar o formulário
        setData: ƒ (r)            => setar todos os dados dentro de um campo
        setErrors: ƒ (r)          => setar todos os erros do formulário
        setFieldError: ƒ (r, n)   => setar o erro de um input específico
        setFieldValue: ƒ (r, n)   => setar o valor de um input específico
        submitForm: ƒ ()          => realizar um submit


- Passamos formRef para o <Form>:
    <Form ref={formRef} onSubmit={handleSubmit}>

Se tentarmos acessar as propriedades de formRef.current não conseguiremos acessar essas funções acima. 
- Precisamos importar FormHandles que é uma interface que tem todas essas tipagens:
    import { FormHandles } from '@unform/core';

- Passamos o retorno para useRef:
    const formRef = useRef<FormHandles>(null);

  Agora em formRef.current. teremos acesso às tipagens.

Só para testarmos vamos colocar um erro estático dentro do catch:
  catch (err) {
    formRef.current?.setErrors({
      name: 'Nome obrigatório',
    })
  }

- Em src/components/Input/index.tsx apenas colocamos no fim do Container, abaixo do <input>:
    {error}

- Voltando ao src/pages/SignUp/index.tsx:
    Vamos colocar um console.log(err) para entender:
      ValidationError {name: "ValidationError", value: {…}, path: undefined, type: undefined, errors: Array(3), …}
        errors: (3) ["Nome obrigatório", "E-mail obrigatório", "No mínimo 6 dígitos"]
        inner: Array(3)
          0: ValidationError {name: "ValidationError", value: "", path: "name", type: "required", errors: Array(1), …}
          1: ValidationError {name: "ValidationError", value: "", path: "email", type: "required", errors: Array(1), …}
          2: ValidationError {name: "ValidationError", value: "", path: "password", type: "min", errors: Array(1), …}
          length: 3
          __proto__: Array(0)
        message: "3 errors occurred"
        name: "ValidationError"
        path: undefined
        type: undefined
        value: {name: "", email: "", password: ""}
        stack: "ValidationError: 3 errors occurred↵    at http://localhost:3000/static/js/1.chunk.js:64368:30↵    at async http://localhost:3000/static/js/main.chunk.js:344:7"
        __proto__: Error

    Ele retorna inner dentro do ValidationError com os campos abaixo:
        path: o caminho para o erro
        message: a mensagem do erro 

- Vamos criar um objeto para cada um dos erros que estão contidos dentro do inner e pegar o name e message. Como usaremos isso várias vezes, criaremos um novo arquivo:
- Em src/utils/getValidationErrors.ts:
    Se colocarmos como retorno dessa forma (Error padrão do JS) não teremos acesso a todos os campos. Então precisamos utilizar o ValidationError do yup:
      - Importamos:
          import { ValidationError } from 'yup';

      - Colocamos no retorno:
          export default function getValidationErrors(err: ValidationError) {
          }

        Agora com err. teremos acesso a todos os campos de ValidationError vistos acima.
        Qual será o retorno dessa função? Lembrando que o formato será uma chave do tipo string e um valor também do tipo string, criaremos uma interface:
          interface Errors {
            [key: string]: string;
          }

        Criando dessa forma informamos que qualquer chave será do tipo string.
        key: pode ser qualquer nome e será do tipo string
      
      - Criamos uma variável do tipo Errors com valor inicial nulo:
          const validationErrors: Errors = {};

      - Como inner é um array, vamos percorrê-lo e preencher validationErrors conforme os dados {path: message} e retorná-lo:
          err.inner.forEach(error => {
            validationErrors[error.path] = error.message;
          });
      
          return validationErrors;

- Em src/pages/SignUp/index.tsx:
  - Importamos a função criada:
      import getValidationErrors from '../../utils/getValidationErrors';

  - Alteramos o catch para ficar dinâmico:
      catch (err) {
        const errors = getValidationErrors(err);
        formRef.current?.setErrors(errors);
      }

  - Precisamos fazer com que ele sempre faça a validação do zero no início da função:
      formRef.current?.setErrors({});

Agora já temos as mensagens aparecendo nos inputs.



*****************************
* OS ARQUIVOS FICARAM ASSIM *
*****************************

- Em src/pages/SignUp/index.tsx:
    import React, { useCallback, useRef } from 'react';
    import { FormHandles } from '@unform/core';
    import { Form } from '@unform/web';
    import { FiMail, FiLock, FiUser, FiArrowLeft } from 'react-icons/fi';
    import * as Yup from 'yup';
    import getValidationErrors from '../../utils/getValidationErrors';
    import { Container, Content, Background } from './styles';
    import logoImg from '../../assets/logo.svg';
    import Input from '../../components/Input';
    import Button from '../../components/Button';

    const SignUp: React.FC = () => {
      const formRef = useRef<FormHandles>(null);
      console.log(formRef);

      const handleSubmit = useCallback(async (data: object) => {
        try {
          formRef.current?.setErrors({});
          const schema = Yup.object().shape({
            name: Yup.string().required('Nome obrigatório'),
            email: Yup.string().required('E-mail obrigatório').email('Digite um e-mail válido'),
            password: Yup.string().min(6, 'No mínimo 6 dígitos'),
          });

          await schema.validate(data, {
            abortEarly: false,
          });
        } catch (err) {
            const errors = getValidationErrors(err);
            formRef.current?.setErrors(errors);
        }
      }, []);

      return (
        <Container>
          <Background />
          <Content>
            <img src={logoImg} alt="GoBarber" />
            <Form ref={formRef} onSubmit={handleSubmit}>
              <h2>Faça seu cadastro</h2>
              <Input name="name" icon={FiUser} placeholder="Nome" />
              <Input name="email" icon={FiMail} placeholder="E-mail" />
              <Input name="password" icon={FiLock} type="password" placeholder="Senha" />
              <Button type="submit">Cadastrar</Button>
            </Form>
            <a href="login">
              <FiArrowLeft />
            Voltar para login
          </a>
          </Content>
        </Container>
      );
    };

    export default SignUp;

- Em src/components/Input/index.tsx:
    import React, { InputHTMLAttributes, useEffect, useRef, useState, useCallback } from 'react';
    import { useField } from '@unform/core';
    import { IconBaseProps } from 'react-icons';
    import { Container } from './styles';

    interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
      name: string;
      icon?: React.ComponentType<IconBaseProps>;
    }

    const Input: React.FC<InputProps> = ({ name, icon: Icon, ...rest }) => {
      const inputRef = useRef<HTMLInputElement>(null);
      const [isFocused, setIsFocused] = useState(false);
      const [isFilled, setIsFilled] = useState(false);
      const { fieldName, defaultValue, error, registerField } = useField(name);

      const handleInputFocus = useCallback(() => {
        setIsFocused(true);
      }, []);

      const handleInputBlur = useCallback(() => {
        setIsFocused(false)

        setIsFilled(!!inputRef.current?.value);
      }, []);

      useEffect(() => {
        registerField({
          name: fieldName,
          ref: inputRef.current,
          path: 'value',
        });
      }, [fieldName, registerField]);

      return (
        <Container isFilled={isFilled} isFocused={isFocused}>
          {Icon && <Icon size={20} />}
          <input
            onFocus={handleInputFocus}
            onBlur={handleInputBlur}
            defaultValue={defaultValue}
            ref={inputRef}
            {...rest} />

            {error}
        </Container>
      );
    };

    export default Input;

- Em src/utils/getValidationErrors.ts:
    import { ValidationError } from 'yup';

    interface Errors {
      [key: string]: string;
    }

    export default function getValidationErrors(err: ValidationError): Errors {
      const validationErrors: Errors = {};

      err.inner.forEach(error => {
        validationErrors[error.path] = error.message;
      });

      return validationErrors;
    }


********************
* FIM DOS ARQUIVOS *
********************


Melhorando as informações de erro no formulário.

Vamos colocar uma borda vermelha no input quando tiver um erro.

- Em src/components/Input/index.tsx passamos uma propriedade para o Container:
    <Container isErrored={!!error} ...>

  Se tiver um erro ficará true e caso contrário false.

- Em src/components/Input/styles.ts:
  - Incluímos na interface:
      isErrored: boolean;

  - Colocamos o estilo do isErrored acima de isFocused e isFilled:
      ${(props) =>
        props.isErrored && css`
          border-color: #c53030;
      `}

Colocando um ícone no lado direito da mensagem e quando o mouse for passado por cima dele mostrará a mensagem de erro:
- Importamos o ícone:
    import { FiAlertCircle } from 'react-icons/fi';

- Em src/components/Input/index.tsx precisamos informar se tiver um erro mostrar a mensagem:
    {error && <FiAlertCircle color="#c53030" size={20} />}

  Se fizermos dessa forma o ícone não ficará totalmente à direita porque setamos anteriormente uma margin-right de 16px. Vamos criar um componente <Error> para mostrar a mensagem e o ícone:
    {error && (
      <Error>
        <FiAlertCircle color="#c53030" size={20} />
      </Error>
    )}

  Vamos importar de styles.css e já vamos criar os estilos:
    import { Container, Error } from './styles';

- Em src/components/Input/styles.ts:
    export const Error = styled.div`
      height: 20px;
      margin-left: 16px;
      
      svg {
        margin:0;
      }
    `;

  height: para fixar o tamanho pois aumenta com a borda e não queremos isso
  margin-left: para que o texto do input não fique por trás do ícone
  svg: margin => para o ícone ficar a direita, retirando o margin-right anterior.


TOOLTIP
=======

Criaremos um componente separado para o tooltip porque usaremos em outros lugares:
Vamos deixar criado o arquivo de estilo:
- Em src/components/Tooltip/styles.ts:
    import styled from 'styled-components';

    export const Container = styled.div``;

- Em src/components/Tooltip/index.tsx:
  import React from 'react';
  import { Container } from './styles';

  interface TooltipProps {
    title: string;
  }

  const Tooltip: React.FC<TooltipProps> = ({ title, children }) => {
    return (
      <Container>
        {children}
        <span>{title}</span>
      </Container>
    )
  }

  export default Tooltip;

HERDANDO UMA CLASSE DE UM COMPONENTE PAI
- Em src/components/Input/styles.ts:
  - Importamos Tooltip:
      import Tooltip from '../Tooltip';

  - Ao invés de dizermos que Error é uma <div>, diremos que é um Tooltip:
      export const Error = styled(Tooltip)`
        height: 20px;
        margin-left: 16px;
        
        svg {
          margin:0;
        }
      `;

    Dessa forma estamos estilizando um Tooltip, ou seja, ele vai no Tooltip, vai entender que o Tooltip tem o <Container> e essas regras de estilização que colocamos no erro em src/components/Input/styles.ts serão aplicados no <Container> do Tooltip.
    
OBS: TEMOS QUE TOMAR CUIDADO COM UMA COISA. A FORMA COMO O STYLED-COMPONENTS USA PARA ENVIAR A ESTILIZAÇÃO DE UM ELEMENTO SUPERIOR PARA UM ELEMENTO INFERIOR (COMO ESTAMOS FAZENDO EM export const Error = styled(Tooltip)`) QUE É QUASE UMA HERANÇA DE ESTILIZAÇÃO, É ATRAVÉS DA CLASSE PORQUE TODAS AS ESTILIZAÇÕES EM STYLED-COMPONENTS SÃO FEITAS ATRAVÉS DE CLASSES. SE INSPECIONARMOS O ELEMENTO INPUT VEREMOS QUE É TUDO FEITO COM CLASSES. CONFORME MUDAMOS O ESTADO DO INPUT MUDA TAMBÉM A CLASSE DELE.

Daí para passarmos para o Tooltip que ele vai poder receber uma estilização de um elemento superior temos que permitir que ele receba o className como opcional(?) do React.
  - Em src/components/Tooltip/index.tsx:
      Faremos isso na interface
        interface TooltipProps {
          title: string;
          className?: string;
        }

      E passamos para o Container:
        <Container className={className}>

  - Em src/components/Input/index.tsx passamos a propriedade title:
      <Error title={error}>
  

ESTILIZANDO O TOOLTIP
=====================

- Em src/components/Tooltip/styles.ts:
    position: relative => assim todo position absolute que está dentro desse Container será 
                          relativo ao Container e não ao restante da tela.
    position: absolute; => será relativo ao Container e não ao restante da tela
    opacity: 0; => para ficar escondido quando não tiver mouse por cima
    transition: opacity 0.4s; => para aparecer gradualmente quando passar o mouse por cima
    visibility: hidden; => para esconder quando o mouse não estiver exatamente em cima do ícone
    visibility: visible; => para mostrar quando o mouse estiver exatamente em cima do ícone
    bottom: calc(100% + 12px); => para o tooltip ficar um pouco para cima da linha do ícone
    left: 50%; => tooltip começará exatamente acima do ícone
    transform: translateX(-50%); => tooltip ficará centralizado acima do ícone
    
COMO FAZER A SETINHA DO TOOLTIP COM CSS:
  &::before {
    content: '';
    border-style: solid;
    border-color: #FF9000 transparent;
    border-width: 6px 6px 0 6px;
    top: 100%;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }

- Em src/components/Input/styles.ts mudaremos o tooltip para vermelho e fonte branca:
    span {
      background: #C53030;
      color: #FFF;

      &::before {
        border-color: #C53030 transparent;
      }
    }


*****************************
* OS ARQUIVOS FICARAM ASSIM *
*****************************

- Em src/components/Input/index.tsx:
    import React, { InputHTMLAttributes, useEffect, useRef, useState, useCallback } from 'react';
    import { useField } from '@unform/core';
    import { IconBaseProps } from 'react-icons';
    import { FiAlertCircle } from 'react-icons/fi';
    import Tooltip from '../Tooltip';
    import { Container, Error } from './styles';

    interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
      name: string;
      icon?: React.ComponentType<IconBaseProps>;
    }

    const Input: React.FC<InputProps> = ({ name, icon: Icon, ...rest }) => {
      const inputRef = useRef<HTMLInputElement>(null);
      const [isFocused, setIsFocused] = useState(false);
      const [isFilled, setIsFilled] = useState(false);
      const { fieldName, defaultValue, error, registerField } = useField(name);

      const handleInputFocus = useCallback(() => {
        setIsFocused(true);
      }, []);

      const handleInputBlur = useCallback(() => {
        setIsFocused(false)

        setIsFilled(!!inputRef.current?.value);
      }, []);

      useEffect(() => {
        registerField({
          name: fieldName,
          ref: inputRef.current,
          path: 'value',
        });
      }, [fieldName, registerField]);

      return (
        <Container isErrored={!!error} isFilled={isFilled} isFocused={isFocused}>
          {Icon && <Icon size={20} />}
          <input
            onFocus={handleInputFocus}
            onBlur={handleInputBlur}
            defaultValue={defaultValue}
            ref={inputRef}
            {...rest} />

          {error && (
            <Error title={error}>
              <FiAlertCircle color="#c53030" size={20} />
            </Error>
          )}
        </Container>
      );
    };

    export default Input;

- Em src/components/Input/styles.ts::
    import styled, { css } from 'styled-components';
    import Tooltip from '../Tooltip';

    interface ContainerProps {
      isFocused: boolean;
      isFilled: boolean;
      isErrored: boolean;
    }

    export const Container = styled.div<ContainerProps>`
        background: #232129;
        border-radius: 10px;
        border: 2px solid #232129;
        padding: 12px;
        width: 100%;
        color: #666360;

        display: flex;
        align-items: center;

        & + div {
          margin-top: 8px;
        }

        ${(props) =>
          props.isErrored && css`
            border-color: #c53030;
        `}

        ${(props) =>
          props.isFocused && css`
            color: #ff9000;
            border-color: #ff9000;
        `}

        ${(props) =>
          props.isFilled && css`
            color: #ff9000;
        `}

      input {
        flex: 1;
        background: transparent;
        border: 0;
        color:#f4ede8;

        &::placeholder {
          color: #666360;
        }

      }
      svg {
        margin-right: 16px;
      }
    `;

    export const Error = styled(Tooltip)`
      height: 20px;
      margin-left: 16px;
      
      svg {
        margin:0;
      }

      span {
        background: #C53030;
        color: #FFF;

        &::before {
          border-color: #C53030 transparent;
        }
      }
    `;

- Em src/components/Tooltip/index.tsx:
    import React from 'react';
    import { Container } from './styles';

    interface TooltipProps {
      title: string;
      className?: string;
    }

    const Tooltip: React.FC<TooltipProps> = ({ title, className, children }) => {
      return (
        <Container className={className}>
          {children}
          <span>{title}</span>
        </Container>
      )
    }

    export default Tooltip;

- Em src/components/Tooltip/styles.ts:
    import styled from 'styled-components';

    export const Container = styled.div`
      position: relative;

      span {
        width: 160px;
        background: #FF9000;
        padding: 8px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.4s;
        visibility: hidden;

        position: absolute;
        bottom: calc(100% + 12px);
        left: 50%;
        transform: translateX(-50%);

        color: #312e38;

        &::before {
          content: '';
          border-style: solid;
          border-color: #FF9000 transparent;
          border-width: 6px 6px 0 6px;
          top: 100%;
          position: absolute;
          left: 50%;
          transform: translateX(-50%);
        }
      }
        &:hover span {
          opacity: 1;
          visibility: visible;
        }
    `;

********************
* FIM DOS ARQUIVOS *
********************


VALIDAÇÃO DE LOGIN
==================

Como não temos rotas ainda, voltaremos a mostrar SignIn:
- Em src/App.tsx:
    import React from 'react';
    import SignIn from './pages/SignIn';
    // import SignUp from './pages/SignUp';
    import GlobalStyle from './styles/global';


    const App: React.FC = () => (
      <>
        <SignIn />
        {/* <SignUp /> */}
        <GlobalStyle />
      </>
    );

    export default App;

- Em src/pages/SignIn/index.tsx:
  - Importamos:
      import React, { useCallback, useRef } from 'react';
      import { FormHandles } from '@unform/core';
      import { Form } from '@unform/web';
      import * as Yup from 'yup';
      import getValidationErrors from '../../utils/getValidationErrors';

  - Trocamos <form> por <Form> e passamos a ref e o onSubmit:
      <Form ref={formRef} onSubmit={handleSubmit}>

  - Retiramos nome porque não precisamos:
      name: Yup.string().required('Nome obrigatório'),



CONECTANDO FRONTEND X BACKEND
=============================

AUTENTICAÇÃO
============

O CORS evita que sites que não sejam confiáveis da nossa aplicação possam acessar o nosso site.
- Instalar CORS:
    yarn add cors

- Em backend/src/server.ts:
  - Importamos CORS:
      import cors from 'cors';

  - Logo abaixo de const app = express();:
      app.use(cors());
      


CONTEXT API
===========

Serve para caso tivermos um estado armazenado em um componente e precisarmos passar para um outro.

Imagina se quisermos criar um contexto de autenticação. Quando uma informação será utilizada por vários locais faz sentido criarmos esse contexto. Vamos criar um arquivo:
- Em frontend/src/context/AuthContext.tsx :
  - Importamos o createContext:
      import { createContext } from 'react';

  - Criamos uma interface para informar qual que será o formato desse contexto:
      interface AuthContextData {
        name: string;
      }

  - Criamos um contexto:
      const AuthContext = createContext<AuthContextData>();
  
      export default AuthContext;
  
  Porém dará um erro porque o Typescript espera como primeiro parâmetro um valor inicial do contexto mas pensando num contexto de autenticação o valor inicial não pode ser algo como o nome do usuário({name: 'Amauri'}), então precisamos deixar isso vazio. Poderíamos fazer assim mas isso dará problemas futuros:
    const AuthContext = createContext<AuthContextData | null>(null);
  
  Existe uma forma melhor de fazermos isso que burla o Typescript e assim ele deixa inicializar o contexto com um objeto vazio ({} as AuthContextData):
  - Colocaremos isso:
      import { createContext } from 'react';

      interface AuthContextData {
        name: string;
      }

      const AuthContext = createContext<AuthContextData>({} as AuthContextData);

      export default AuthContext;

- Em src/App.tsx:
  - Importamos AuthContext:
      import AuthCOntext from './context/AuthContext';

  Dentro de AuthContext existem algumas propriedades, dentre elas a Provider que é a mais importante agora. AuthContext.Provider ele é um componente que vamos colocar por volta dos componentes que queremos que tenham acesso ao contexto de autenticação. Todo componente dentro dele terá acesso ao contexto de autenticação mas no AuthContext.Provider precisamos passar qual que é o valor do nosso contexto (value={{}}). Se usarmos CTRL+espaço veremos as opções.
  Passando o value para AuthContext.Provider o SignIn já terá acesso.
    const App: React.FC = () => (
      <>
        <AuthContext.Provider value={{ name: 'Amauri' }}>
          <SignIn />
        </AuthContext.Provider>

        <GlobalStyle />
      </>
    );

- Em frontend/src/pages/SignIn/index.tsx:
  - Importamos useContext e AuthContext:
      import React, { useCallback, useRef, useContext } from 'react';
      import AuthContext from '../../context/AuthContext';

    useContext: é um hook do React para termos acesso ao context

  - No início do componente, onde está formRef:
      const auth = useContext(AuthContext);
      console.log(auth);

    Podemos ver no console do navegador o objeto:
      name: "Amauri"

    E desestruturando retornará Amauri:
      const { name } = useContext(AuthContext);
      console.log(name);


LOGIN PELO CONTEXTO
===================

Agora que já vimos como funciona o contexto, começaremos a fazer o login do GoBarber com ele.
- Em frontend/src/context/AuthContext.tsx:
    import React, { createContext, useCallback } from 'react';

    interface AuthContextData {
      name: string;
      signIn(): void;
    }

    export const AuthContext = createContext<AuthContextData>({} as AuthContextData);

    export const AuthProvider: React.FC = ({ children }) => {
      const signIn = useCallback(() => {
        console.log(signIn);
      }, []);
      
      return (
        <AuthContext.Provider value={{ name: 'Amauri', signIn }}>
          {{ children }}
        </AuthContext.Provider>
      );
    };

  Criamos o componente AuthProvider que recebe children(tudo que receber como filho passamos para algum lugar dentro do context AuthProvider).
  Criamos o método signIn que fará a autenticação na nossa aplicação (usando o useCallback porque está dentro de outra função) que por enquanto só terá um console.log().
  Passamos o signIn para o AuthProvider e informamos na interface com tipo void(sem retorno).
  Exportamos cada um colocando o export antes do const para importá-los em outro local dentro de chaves o que quisermos.
  Ou seja, isolamos tudo que tem a ver com o contexto de autenticação, como o próprio valor inicial desse contexto, dentro desse arquivo de contexto facilitando a visualização e manutenção com organização.

- Em frontend/src/App.tsx:
    import React from 'react';
    import SignIn from './pages/SignIn';
    import GlobalStyle from './styles/global';
    import { AuthProvider } from './context/AuthContext';

    const App: React.FC = () => (
      <>
        <AuthProvider>
          <SignIn />
        </AuthProvider>

        <GlobalStyle />
      </>
    );

    export default App;

  Importamos apenas o AuthProvider e o passamos para o App, ficando bem melhor.

- Em frontend/src/pages/SignIn/index.tsx:
  - Mudamos o import, colocando o AuthContext entre chaves para termos acesso ao contexto geral:
      import { AuthContext } from '../../context/AuthContext';

  - Agora temos acesso ao signIn:
      const { signIn } = useContext(AuthContext);
      console.log(signIn);

    Vamos chamá-lo dentro do try de handleSubmit:
      signIn();

    Passar como dependência essa variável externa no final de handleSubmit:
      }, [signIn]);

  A resposta no console do browse será: signIn



MELHORANDO SIGNIN
=================

- Instalar AXIOS:
    yarn add axios

- Em frontend/src/services/api.ts vamos criar a API:
    import axios from 'axios';

    const api = axios.create({
      baseURL: 'http://localhost:3333',
    });

    export default api;

- Em frontend/src/context/AuthContext.tsx:
  - Importamos axios:  
      import api from '../services/api';

  - Transformamos a função em async/await pegando os dados vindos do formulário:
        const signIn = useCallback(async ({ email, password }) => {
          const response = await api.post('sessions', {
            email, 
            password
          });
          console.log(response.data);
        }, []);

    - Como usamos async/await precisamos informar que o retorno é uma Promise.
    - Informamos o que signIn recebe na interface (credentials).
    - E credentials precisa de uma interface falando qual que é o formato.
      - Podemos ver essas mudanças abaixo:
          interface SignInCredentials {
            email: string;
            password: string;
          }

          interface AuthContextData {
            name: string;
            signIn(credentials: SignInCredentials): Promise<void>;
          }

- Em frontend/src/pages/SignIn/index.tsx:
  - Enviamos email e password que estão contidos no data:
      signIn({
        email: data.email,
        password: data.password,
      });
  
    - Precisamos criar uma interface para informar que data não é mais um object:
        interface SignInFormData {
          email: string;
          password: string;
        }

Agora no console podemos ver os dados do usuário incluindo seu token.


SALVANDO O USUÁRIO NO LOCALSTORAGE
==================================

- Em frontend/src/context/AuthContext.tsx:
  - Depois que fizermos o processo de autenticação, iremos buscar os dados do usuário de dentro de response:
      const { token, user } = response.data;

    O Typescript reclamará que falta a tipagem mas não tem problema agora.

  - Armazenamos no localStorage o token e o user.
    O '@GoBarber:...' vai aparecer no localStorage do navegador e serve para diferenciar dos demais.
    Como user é um objeto, precisamos transformá-lo em string usando JSON.stringify()
      localStorage.setItem('@GoBarber:token', token);
      localStorage.setItem('@GoBarber:user', JSON.stringify(user));

  - Após isso armazenamos na nossa aplicação porque não vamos acessar esses dados do localStorage, não faz sentido, pois já temos esses dados no response.data. Então salvamos para depois passar via contexto para todos os componentes. Então criaremos estados:
    import React, { createContext, useCallback, useState } from 'react';

    - Em AuthProvider:
      Poderíamos fazer assim já feito como anteriormente:
        const [data, setData] = useState<AuthState>({} as AuthState);
      
      Mas inicializaremos essa variável utilizando uma função porque queremos buscar o valor dessa variável data no início baseado nos dados dentro do localStorage. Se já tiver preenchido o token e o user então já preenchemos o estado inicial dela com esses dados, caso contrário iniciamos com valor vazio.
      - Verificamos se existe qa informação de token e user retornando o valor inicial para o estado do AuthState a informação de token e user sendo JSON.parse(user) para transformá-lo em objeto. Se não encontrou, retorna um objeto vazio como AuthState:
        const [data, setData] = useState<AuthState>(() => {
          const token = localStorage.getItem('@GoBarber:token');
          const user = localStorage.getItem('@GoBarber:user');

          if (token && user) {
            return { token, user: JSON.parse(user) };
          }
          return {} as AuthState;
        });

        Essa lógica só será executada quando o usuário der um refresh na página ou quando ele sair e voltar para o software para carregar as informações que estão no storage.
        O data nós iremos passá-lo no return em AuthContext.Provider:
          <AuthContext.Provider value={{ user: data.user, signIn }}>
        
        E precisamos alterar a interface para torná-la dinâmica com o user:
          interface AuthContextData {
            user: object;
            signIn(credentials: SignInCredentials): Promise<void>;
          }

      - Em signIn abaixo de response:
          const { token, user } = response.data;

          localStorage.setItem('@GoBarber:token', token);
          localStorage.setItem('@GoBarber:user', JSON.stringify(user));

          setData({ token, user });

          No momento que fazemos o login, o estado useState<AuthState> já foi criado e o bloco de código não será executado, ou seja, não irá buscar novamente no localStorage. Então, logo depois de fazer o login vamos setar o estado de data preenchendo com token e user. Isso irá incluir esses dados enquanto nossa aplicação está executando.

    - Criamos uma interface passando o user como object porque os dados podem ser alterados:
        interface AuthState {
          token: string;
          user: object;
        }

- Em frontend/src/pages/SignIn/index.tsx:
    const { user, signIn } = useContext(AuthContext);
    console.log(user);

    Resposta:
      Undefined
      Object
        avatar: null
        created_at: "2020-09-01T00:12:48.841Z"
        email: "amauri@gmail.com"
        id: "b24e17dc-ef4f-4216-ba48-2bcd1ebb4c9d"
        name: "Amauri"
        updated_at: "2020-09-01T00:12:48.841Z"
        __proto__: Object

      Primeiramente aparece como Undefined.
      Após digitarmos os dados válidos retorna Object com os dados do usuário.
      Ao fazermos o refresh da página ele já some o Undefined retornando apenas o Object porque agora já está salvo no localStorage. Podemos vê-lo acessando as Ferramentas do Desenvolvedor no navegador -> Application -> Local Storage.











