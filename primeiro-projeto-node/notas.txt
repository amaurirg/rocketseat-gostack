- Criar pasta primeiro-pojeto-node
- Criar package.json:
  yarn init -y
- Instalar as dependências:
  yarn add express
  yarn tsc --init
- Criar pasta src com arquivo server.ts
    import express from 'express';

    const app = express();

    app.get('/', (request, response) => {
      return response.json({message: 'Hello World'});
    })

    app.listen(3333, () => {
      console.log('Server started on port 3333');
    });
- Em tsconfig.json descomente e preencha com as pastas:
    "outDir": "./dist",
    "rootDir": "./src",
- Converta os arquivos ts em js:
  yarn tsc
- Em server.ts:
  import express from 'express';
  Ficará com erro informando que precisamos instalar o pacote:
    yarn add @types/express -D
- Execute o projeto:
    yarn tsc
    node dist/server.js
Para não ter que fazer esses procedimentos instalaremos uma ferramenta que é muito rápida e fará o build (como o tsc) e restart do servidor automaticamente (como o nodemon).
- Configurar package.json:
  ... omitido
    "license": "MIT",
    "scripts": {
      "build": "tsc"
    },
    "dependencies": {
  ... omitido
- Deletar a pasta dist.
- Instalar o pacote:
  yarn add ts-node-dev -D
- Inclua "dev-server" em package.json:
    ... omitido
    "license": "MIT",
      "scripts": {
        "build": "tsc",
        "dev:server": "ts-node-dev --transpileOnly --ignore-watch node_modules src/server.ts"
      },
      "dependencies": {
      ... omitido
    --transpileOnly: para não verificar se o código está correto já que o VSCode faz isso
    --ignore-watch node_modules: para ignorar a verificação de alteração na pasta node_modules
- Execute o projeto:
    yarn dev:server

DEBUG NO VSCODE
===============
- Clicar no ícone DEBUG
- Clicar em create a launch.json file
    {
      // Use IntelliSense to learn about possible attributes.
      // Hover to view descriptions of existing attributes.
      // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
      "version": "0.2.0",
      "configurations": [
        {
          "type": "node",
          "request": "launch",
          "name": "Launch Program",
          "skipFiles": [
            "<node_internals>/**"
          ],
          "program": "${workspaceFolder}/index.js",
          "outFiles": [
            "${workspaceFolder}/**/*.js"
          ]
        }
      ]
    }
- Alterar o arquivo launch.json:
    {
      // Use IntelliSense to learn about possible attributes.
      // Hover to view descriptions of existing attributes.
      // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
      "version": "0.2.0",
      "configurations": [
        {
          "type": "node",
          "request": "attach",
          "protocol": "inspector",
          "restart": true,
          "name": "Debug",
          "skipFiles": [
            "<node_internals>/**"
          ],
          "outFiles": [
            "${workspaceFolder}/**/*.js"
          ]
        }
      ]
    }
    O launch só executa a aplicação com o debug. O attach tenta conectar o debug na aplicação.
- Execute o projeto:
    yarn dev:server
    Se tentar debugar agora não irá funcionar porque o debug não está conectado. O protocol inspector serve para essa conexão e tem que especificar --inspect no package.json:
      "dev:server": "ts-node-dev --inspect --transpileOnly --ignore-watch node_modules src/server.ts"
- Execute o projeto:
    yarn dev:server
  - Clique Run Debug
    A barra abaixo ficará vermelha, o terminal informará que o debugger está ouvindo e poderemos usar breakpoints.
  

  ROUTES
  ======

  - Vamos dividir as rotas em arquivos separados.
    - Crie um arquivo src/routes/appointments.routes.ts:
      import { Router } from 'express';
      import { uuid } from 'uuidv4';

      const appointmentsRouter = Router();

      const appointments = [];

      appointmentsRouter.post('/', (request, response) => {
          const { provider, date } = request.body;
          const appointment = {
              id: uuid(),
              provider,
              date
          }
          appointments.push(appointment)
          return response.json(appointment);
      });

      export default appointmentsRouter;
    
    - Em src/routes/index.ts:
      import { Router } from 'express';
      import appointmentsRouter from './appointments.routes';

      const routes = Router();

      routes.use('/appointments', appointmentsRouter);

      export default routes;
    
    Usamos "use" informando onde deverá ser tratada a rota para qualquer método (post, get, etc.).
    Em appointments.routes.ts criamos um array que recebe os dados de request.body através de appointment.
    Por enquanto não temos validação de nada, podendo ser adicionado vários com o mesmo horário.


- Instalar DATE FNS para trabalharmos com datas
    yarn add date-fns
- Importe DATE FNS em appointments.routes.ts:
    import { startOfHour, parseISO } from 'date-fns';
      parseISO converte uma string em objeto date
      startOfHour zera os minutos, segundos e milisegundos, deixando a hora no formato T20:00:00.000Z
- Declare a variável no formato convertido:
    const parsedDate = startOfHour(parseISO(date));
- Na criação do objeto colocaremos essa data:
    const appointment = {
        id: uuid(),
        provider,
        date: parsedDate
    }
- Vamos procurar agendamentos com a mesma data:
    - Importe isEqual para comparar as datas:
        import { startOfHour, parseISO, isEqual } from 'date-fns';
- Percorre o array fazendo a comparação se existe alguma data igual ao que recebemos em request.body:
    const findAppointmentInSameDate = appointments.find(appointment =>
        isEqual(parsedDate, appointment.date),
    );
- Se tiver uma data igual retornaremos um erro:
    if(findAppointmentInSameDate) {
        return response.status(400).json({message: "This appointment is already booked"});
    }
- Precisamos criar uma interface para appointments:
    interface Appointment {
        id: string,
        provider: string,
        date: Date;
    }
- Declare que esse array é composto pela interface criada:
    const appointments: Appointment[] = [];



MODELS
======
Toda vez que criarmos um dado que será armazenado na aplicação, criaremos um model.
- Crie o arquivo src/models/Appointment.ts
    import { uuid } from 'uuidv4';

    class Appointment {
        id: string;
        provider: string;
        date: Date;

        constructor(provider: string, date: Date) {
            this.id = uuid();
            this.provider = provider;
            this.date = date;
        }
    }

    export default Appointment;
    constructor: para passarmos parâmetros em "new Appointment()"
    
- Agora apagamos a interface e importamos o model em appointments.routes.ts:
    import Appointment from '../models/Appointments';
    A declaração da variável fica igual:
      const appointments: Appointment[] = [];
- Substituir a forma de como criamos o objeto:
    const appointment = {
        id: uuid(),
        provider,
        date: parsedDate
    }
    PARA:
    const appointment = new Appointment(provider, parsedDate);
- Não precisamos mais de uuid em appointments.routes.ts pois isso é feito agora em models



REPOSITÓRIOS
============

Responsável pelo CRUD.
É a conexão entre Persistência (onde iremos persistir os dados como DB), Repositório e Rota.
Persistência <-> Repositório <-> Rota
É um detentor das operações que iremos fazer em cima dos dados da aplicação.
Sempre que formos armazenar dados, os repositórios serão utilizados para realizarmos as operações em cima deles (CRUD).
No repositório iremos buscar as informações persistidas em um DB ou variável.
Podemos ter um find para procurar ou create para criar.
Normalmente teremos um repositório por model.
- Crie o arquivo src/repositories/AppointmentsRepository.ts que será responsável por tudo que irá mexer nos dados de agendamento de alguma forma:
    import Appointment from '../models/Appointment';


    class AppointmentsRepository {
        private appointments: Appointment[];

        constructor() {
            this.appointments = [];
        }

        public create(provider: string, date: Date): Appointment {
            const appointment = new Appointment(provider, date);
            this.appointments.push(appointment);

            return appointment;
        }
    }

    export default AppointmentsRepository;

private: acessível somente pela classe e seus métodos
public: acessível fora da classe
constructor: inicializa a variável
create(): cria o objeto e adiciona em appointments
public create(provider: string, date: Date): Appointment { ==> precisamos informar o tipo de retorno (Appointment)

- Em appointments.routes.ts:
  - Importamos
      import AppointmentsRepository from '../repositories/AppointmentsRepository';
  - Criamos a instância appointmentsRepository de AppointmentsRepository:
      - Substituir:
          const appointments: Appointment[] = [];
        Por:
          const appointmentsRepository = new AppointmentsRepository();
  - Chamamos o método create para criarmos o objeto:
      const appointment = appointmentsRepository.create(provider, parsedDate);
  - Deletamos o push porque será feito no AppointmentsRepository.ts
  - Precisamos criar um método público para procurar pelos agendamentos em AppointmentsRepository.ts porque appointments não é acessível (private)

- Em AppointmentsRepository.ts:
    Passaremos a lógica de appointments.routes.ts para dentro do método findByDate:
      const findAppointmentInSameDate = appointments.find(appointment =>
          isEqual(parsedDate, appointment.date),
      );
    E faremos as alterações necessárias:
      public findByDate(date: Date): Appointment | null {
        const findAppointment = this.appointments.find(appointment =>
            isEqual(date, appointment.date),
        );
        return findAppointment || null;
      }
      Informamos que retornará Appointment ou nulo
        public findByDate(date: Date): Appointment | null
      Retornará findAppointment ou nulo
        return findAppointment || null;

- Em appointments.routes.ts:
    - Chamamos o método findByDate passando a data:
        const findAppointmentInSameDate = appointmentsRepository.findByDate(
          parsedDate,
        );
    - A verificação com "if" continua igual.

Com essas mudanças os arquivos ficaram assim:

- Em appointments.routes.ts:
    import { Router } from 'express';
    import { startOfHour, parseISO, isEqual } from 'date-fns';
    import AppointmentsRepository from '../repositories/AppointmentsRepository';

    const appointmentsRouter = Router();
    const appointmentsRepository = new AppointmentsRepository();

    appointmentsRouter.post('/', (request, response) => {
        const { provider, date } = request.body;
        const parsedDate = startOfHour(parseISO(date));
        const findAppointmentInSameDate = appointmentsRepository.findByDate(
            parsedDate,
        );

        if (findAppointmentInSameDate) {
            return response.status(400).json({ message: "This appointment is already booked" });
        }
        
        const appointment = appointmentsRepository.create(provider, parsedDate);
        return response.json(appointment);
    });

    export default appointmentsRouter;

- Em AppointmentsRepository.ts:
    import Appointment from '../models/Appointment';
    import { isEqual } from 'date-fns/esm';


    class AppointmentsRepository {
        private appointments: Appointment[];

        constructor() {
            this.appointments = [];
        }

        public findByDate(date: Date): Appointment | null {
            const findAppointment = this.appointments.find(appointment =>
                isEqual(date, appointment.date),
            );
            return findAppointment || null;
        }

        public create(provider: string, date: Date): Appointment {
            const appointment = new Appointment(provider, date);
            this.appointments.push(appointment);

            return appointment;
        }
    }

    export default AppointmentsRepository;



DTO - Data Transfer Object
==========================

Passando dados nomeados para ficar mais claro o que a função recebe.
Ao invés de passarmos/recebermos parâmetros indicando os tipos na função, criamos uma interface e desestruturamos os dados. Exemplo:
  - Em AppointmentsRepository.ts:
      - Criação da interface:
          interface CreateAppointmentDTO {
            provider: string;

            date: Date;
          }
      - Substituímos:      
          public create(provider: string, date: Date): Appointment {...
        Por:
          public create(data: CreateAppointmentDTO): Appointment {
            const appointment = new Appointment(data.provider, data.date);
        Ou com desestruturação:
          public create({ provider, date }: CreateAppointmentDTO): Appointment {
            const appointment = new Appointment(provider, date);
  - Em appointments.routes.ts passaremos na criação um objeto como parâmetro:
    - Substituímos:
        const appointment = appointmentsRepository.create(provider, parsedDate);
      Por:
        const appointment = appointmentsRepository.create({
          provider,
          date: parsedDate,
        });

No Typescript existe uma função que serve para NÃO pegarmos alguns dados. 
  Omit<Tipo, variável que não queremos>
  - No constructor de Appointments colocaremos o Omit com o tipo Appointment e a variável que não queremos (id):
      import { uuid } from 'uuidv4';

      class Appointment {
          id: string;
          provider: string;
          date: Date;

          constructor({ provider, date }: Omit<Appointment, "id">) {
              this.id = uuid();
              this.provider = provider;
              this.date = date;
          }
      }

      export default Appointment;

Assim quando quisermos adicionar algum campo na classe, o mesmo ficará disponível para o constructor com CTRL + espaço.

  - No método create de AppointmentsRepository:
      public create({ provider, date }: CreateAppointmentDTO): Appointment {
        const appointment = new Appointment({ provider, date });



SERVICES & SOLID
================

Precisamos separar o código de acordo com as responsabilidades pois as rotas estão sobrecarregadas com códigos não devem estar nelas.
As rotas são responsáveis por:
  - Receber a requisição
  - Chamar outro arquivo
  - Devolver uma resposta
O que estiver além disso deve ser colocado em outra parte do código.
- Crie uma pasta services em src
Para a criação de agendamento criaremos um arquivo separado e moveremos parte do código de appointments.routes.ts para ele
- Crie o arquivo CreateAppointmentService.ts
O service sempre terá um único método normalmente chamado de execute ou run

- Em appointments.routes.ts:
  - Separando parseISO que está transformando string em objeto de startOfHour que é uma regra de negócio onde zera os minutos, segundos e milisegundos.
      const parsedDate = startOfHour(parseISO(date));
    Em:
      const parsedDate = parseISO(date);
      const appointmentDate = startOfHour(parsedDate);
    Agora precisamos alterar a variável que tem o valor de date:
      const appointment = appointmentsRepository.create({
        provider,
        date: appointmentDate,
      });
  - Movemos essa parte do código para src/services/CreateAppointmentService.ts:
      const appointmentDate = startOfHour(parsedDate);
      const findAppointmentInSameDate = appointmentsRepository.findByDate(
          parsedDate,
      );

      if (findAppointmentInSameDate) {
          return response.status(400).json({ message: "This appointment is already booked" });
      }
      
      const appointment = appointmentsRepository.create({
          provider,
          date: appointmentDate,
      });
Agora teremos vários erros que precisamos corrigir.
  - Recebimento das informações
  - Tratativa de erros e excessões
  - Acesso ao repositório
- Criamos uma interface:

- Informamos com desestruturação os dados que receberemos e o tipo do retorno:
    public execute({ date, provider }: Request): Appointment {
- Substituiremos o if para retornar um trow com a mensagem de erro:
    if (findAppointmentInSameDate) {
      return response.status(400).json({ message: "This appointment is already booked" });
    }
  Para:
    if (findAppointmentInSameDate) {
      throw Error("This appointment is already booked");
    }
Se fizermos a declaração abaixo em cada criaremos repositórios diferentes:
  const appointmentsRepository = new AppointmentsRepository();
Para isso utilizaremos um princípio chamado Dependency Inversion (SOLID).
Sempre o service tiver uma dependência externa como o caso do AppointmentsRepository ao invés de instanciarmos a classe de repositório dentro do service nós receberemos o appointmentsRepository como parâmetro do constructor da classe. Isso facilita para que independentemente de quantos servicesw diferentes estejam trabalhando com a parte de appointment todos eles estejam utilizando o mesmo repositório de appointment e não vários criados em services diferentes.
- Importamos:
    import AppointmentsRepository from '../repositories/AppointmentsRepository';
- Em constructor:
    - Criamos a variável:
        constructor(appointmentsRepository: AppointmentsRepository){
