- Criar pasta primeiro-pojeto-node
- Criar package.json:
  yarn init -y
- Instalar as dependências:
  yarn add express
  yarn tsc --init
- Criar pasta src com arquivo server.ts
    import express from 'express';

    const app = express();

    app.get('/', (request, response) => {
      return response.json({message: 'Hello World'});
    })

    app.listen(3333, () => {
      console.log('Server started on port 3333');
    });
- Em tsconfig.json descomente e preencha com as pastas:
    "outDir": "./dist",
    "rootDir": "./src",
- Converta os arquivos ts em js:
  yarn tsc
- Em server.ts:
  import express from 'express';
  Ficará com erro informando que precisamos instalar o pacote:
    yarn add @types/express -D
- Execute o projeto:
    yarn tsc
    node dist/server.js
Para não ter que fazer esses procedimentos instalaremos uma ferramenta que é muito rápida e fará o build (como o tsc) e restart do servidor automaticamente (como o nodemon).
- Configurar package.json:
  ... omitido
    "license": "MIT",
    "scripts": {
      "build": "tsc"
    },
    "dependencies": {
  ... omitido
- Deletar a pasta dist.
- Instalar o pacote:
  yarn add ts-node-dev -D
- Inclua "dev-server" em package.json:
    ... omitido
    "license": "MIT",
      "scripts": {
        "build": "tsc",
        "dev:server": "ts-node-dev --transpileOnly --ignore-watch node_modules src/server.ts"
      },
      "dependencies": {
      ... omitido
    --transpileOnly: para não verificar se o código está correto já que o VSCode faz isso
    --ignore-watch node_modules: para ignorar a verificação de alteração na pasta node_modules
- Execute o projeto:
    yarn dev:server

DEBUG NO VSCODE
===============
- Clicar no ícone DEBUG
- Clicar em create a launch.json file
    {
      // Use IntelliSense to learn about possible attributes.
      // Hover to view descriptions of existing attributes.
      // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
      "version": "0.2.0",
      "configurations": [
        {
          "type": "node",
          "request": "launch",
          "name": "Launch Program",
          "skipFiles": [
            "<node_internals>/**"
          ],
          "program": "${workspaceFolder}/index.js",
          "outFiles": [
            "${workspaceFolder}/**/*.js"
          ]
        }
      ]
    }
- Alterar o arquivo launch.json:
    {
      // Use IntelliSense to learn about possible attributes.
      // Hover to view descriptions of existing attributes.
      // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
      "version": "0.2.0",
      "configurations": [
        {
          "type": "node",
          "request": "attach",
          "protocol": "inspector",
          "restart": true,
          "name": "Debug",
          "skipFiles": [
            "<node_internals>/**"
          ],
          "outFiles": [
            "${workspaceFolder}/**/*.js"
          ]
        }
      ]
    }
    O launch só executa a aplicação com o debug. O attach tenta conectar o debug na aplicação.
- Execute o projeto:
    yarn dev:server
    Se tentar debugar agora não irá funcionar porque o debug não está conectado. O protocol inspector serve para essa conexão e tem que especificar --inspect no package.json:
      "dev:server": "ts-node-dev --inspect --transpileOnly --ignore-watch node_modules src/server.ts"
- Execute o projeto:
    yarn dev:server
  - Clique Run Debug
    A barra abaixo ficará vermelha, o terminal informará que o debugger está ouvindo e poderemos usar breakpoints.
  

  ROUTES
  ======

  - Vamos dividir as rotas em arquivos separados.
    - Crie um arquivo src/routes/appointments.routes.ts:
      import { Router } from 'express';
      import { uuid } from 'uuidv4';

      const appointmentsRouter = Router();

      const appointments = [];

      appointmentsRouter.post('/', (request, response) => {
          const { provider, date } = request.body;
          const appointment = {
              id: uuid(),
              provider,
              date
          }
          appointments.push(appointment)
          return response.json(appointment);
      });

      export default appointmentsRouter;
    
    - Em src/routes/index.ts:
      import { Router } from 'express';
      import appointmentsRouter from './appointments.routes';

      const routes = Router();

      routes.use('/appointments', appointmentsRouter);

      export default routes;
    
    Usamos "use" informando onde deverá ser tratada a rota para qualquer método (post, get, etc.).
    Em appointments.routes.ts criamos um array que recebe os dados de request.body através de appointment.
    Por enquanto não temos validação de nada, podendo ser adicionado vários com o mesmo horário.


- Instalar DATE FNS para trabalharmos com datas
    yarn add date-fns
- Importe DATE FNS em appointments.routes.ts:
    import { startOfHour, parseISO } from 'date-fns';
      parseISO converte uma string em objeto date
      startOfHour zera os minutos, segundos e milisegundos, deixando a hora no formato T20:00:00.000Z
- Declare a variável no formato convertido:
    const parsedDate = startOfHour(parseISO(date));
- Na criação do objeto colocaremos essa data:
    const appointment = {
        id: uuid(),
        provider,
        date: parsedDate
    }
- Vamos procurar agendamentos com a mesma data:
    - Importe isEqual para comparar as datas:
        import { startOfHour, parseISO, isEqual } from 'date-fns';
- Percorre o array fazendo a comparação se existe alguma data igual ao que recebemos em request.body:
    const findAppointmentInSameDate = appointments.find(appointment =>
        isEqual(parsedDate, appointment.date),
    );
- Se tiver uma data igual retornaremos um erro:
    if(findAppointmentInSameDate) {
        return response.status(400).json({message: "This appointment is already booked"});
    }
- Precisamos criar uma interface para appointments:
    interface Appointment {
        id: string,
        provider: string,
        date: Date;
    }
- Declare que esse array é composto pela interface criada:
    const appointments: Appointment[] = [];



MODELS
======
Toda vez que criarmos um dado que será armazenado na aplicação, criaremos um model.
- Crie o arquivo src/models/Appointment.ts
    import { uuid } from 'uuidv4';

    class Appointment {
        id: string;
        provider: string;
        date: Date;

        constructor(provider: string, date: Date) {
            this.id = uuid();
            this.provider = provider;
            this.date = date;
        }
    }

    export default Appointment;
    constructor: para passarmos parâmetros em "new Appointment()"
    
- Agora apagamos a interface e importamos o model em appointments.routes.ts:
    import Appointment from '../models/Appointments';
    A declaração da variável fica igual:
      const appointments: Appointment[] = [];
- Substituir a forma de como criamos o objeto:
    const appointment = {
        id: uuid(),
        provider,
        date: parsedDate
    }
    PARA:
    const appointment = new Appointment(provider, parsedDate);
- Não precisamos mais de uuid em appointments.routes.ts pois isso é feito agora em models



REPOSITÓRIOS
============

Responsável pelo CRUD.
É a conexão entre Persistência (onde iremos persistir os dados como DB), Repositório e Rota.
Persistência <-> Repositório <-> Rota
É um detentor das operações que iremos fazer em cima dos dados da aplicação.
Sempre que formos armazenar dados, os repositórios serão utilizados para realizarmos as operações em cima deles (CRUD).
No repositório iremos buscar as informações persistidas em um DB ou variável.
Podemos ter um find para procurar ou create para criar.
Normalmente teremos um repositório por model.
- Crie o arquivo src/repositories/AppointmentsRepository.ts que será responsável por tudo que irá mexer nos dados de agendamento de alguma forma:
    import Appointment from '../models/Appointment';


    class AppointmentsRepository {
        private appointments: Appointment[];

        constructor() {
            this.appointments = [];
        }

        public create(provider: string, date: Date): Appointment {
            const appointment = new Appointment(provider, date);
            this.appointments.push(appointment);

            return appointment;
        }
    }

    export default AppointmentsRepository;

private: acessível somente pela classe e seus métodos
public: acessível fora da classe
constructor: inicializa a variável
create(): cria o objeto e adiciona em appointments
public create(provider: string, date: Date): Appointment { ==> precisamos informar o tipo de retorno (Appointment)

- Em appointments.routes.ts:
  - Importamos
      import AppointmentsRepository from '../repositories/AppointmentsRepository';
  - Criamos a instância appointmentsRepository de AppointmentsRepository:
      - Substituir:
          const appointments: Appointment[] = [];
        Por:
          const appointmentsRepository = new AppointmentsRepository();
  - Chamamos o método create para criarmos o objeto:
      const appointment = appointmentsRepository.create(provider, parsedDate);
  - Deletamos o push porque será feito no AppointmentsRepository.ts
  - Precisamos criar um método público para procurar pelos agendamentos em AppointmentsRepository.ts porque appointments não é acessível (private)

- Em AppointmentsRepository.ts:
    Passaremos a lógica de appointments.routes.ts para dentro do método findByDate:
      const findAppointmentInSameDate = appointments.find(appointment =>
          isEqual(parsedDate, appointment.date),
      );
    E faremos as alterações necessárias:
      public findByDate(date: Date): Appointment | null {
        const findAppointment = this.appointments.find(appointment =>
            isEqual(date, appointment.date),
        );
        return findAppointment || null;
      }
      Informamos que retornará Appointment ou nulo
        public findByDate(date: Date): Appointment | null
      Retornará findAppointment ou nulo
        return findAppointment || null;

- Em appointments.routes.ts:
    - Chamamos o método findByDate passando a data:
        const findAppointmentInSameDate = appointmentsRepository.findByDate(
          parsedDate,
        );
    - A verificação com "if" continua igual.

Com essas mudanças os arquivos ficaram assim:

- Em appointments.routes.ts:
    import { Router } from 'express';
    import { startOfHour, parseISO, isEqual } from 'date-fns';
    import AppointmentsRepository from '../repositories/AppointmentsRepository';

    const appointmentsRouter = Router();
    const appointmentsRepository = new AppointmentsRepository();

    appointmentsRouter.post('/', (request, response) => {
        const { provider, date } = request.body;
        const parsedDate = startOfHour(parseISO(date));
        const findAppointmentInSameDate = appointmentsRepository.findByDate(
            parsedDate,
        );

        if (findAppointmentInSameDate) {
            return response.status(400).json({ message: "This appointment is already booked" });
        }
        
        const appointment = appointmentsRepository.create(provider, parsedDate);
        return response.json(appointment);
    });

    export default appointmentsRouter;

- Em AppointmentsRepository.ts:
    import Appointment from '../models/Appointment';
    import { isEqual } from 'date-fns/esm';


    class AppointmentsRepository {
        private appointments: Appointment[];

        constructor() {
            this.appointments = [];
        }

        public findByDate(date: Date): Appointment | null {
            const findAppointment = this.appointments.find(appointment =>
                isEqual(date, appointment.date),
            );
            return findAppointment || null;
        }

        public create(provider: string, date: Date): Appointment {
            const appointment = new Appointment(provider, date);
            this.appointments.push(appointment);

            return appointment;
        }
    }

    export default AppointmentsRepository;

